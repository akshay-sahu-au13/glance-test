{"id":"vKvL","dependencies":[{"name":"C:\\Users\\Akshay\\OneDrive\\Documents\\GitHub\\GlanceWebpeeks\\user_onboarding\\package.json","includedInParent":true,"mtime":1628275493700},{"name":"C:\\Users\\Akshay\\OneDrive\\Documents\\GitHub\\GlanceWebpeeks\\user_onboarding\\.babelrc","includedInParent":true,"mtime":1627401691025},{"name":"C:\\Users\\Akshay\\OneDrive\\Documents\\GitHub\\GlanceWebpeeks\\user_onboarding\\node_modules\\preact-router\\package.json","includedInParent":true,"mtime":1627540119469},{"name":"preact","loc":{"line":1,"column":69},"parent":"C:\\Users\\Akshay\\OneDrive\\Documents\\GitHub\\GlanceWebpeeks\\user_onboarding\\node_modules\\preact-router\\dist\\preact-router.es.js","resolved":"C:\\Users\\Akshay\\OneDrive\\Documents\\GitHub\\GlanceWebpeeks\\user_onboarding\\node_modules\\preact\\dist\\preact.module.js"}],"generated":{"js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getCurrentUrl = getCurrentUrl;\nexports.route = route;\nexports.exec = exec;\nexports.default = exports.Link = exports.Route = exports.Router = exports.subscribers = void 0;\n\nvar _preact = require(\"preact\");\n\nvar EMPTY$1 = {};\n\nfunction assign(obj, props) {\n  // eslint-disable-next-line guard-for-in\n  for (var i in props) {\n    obj[i] = props[i];\n  }\n\n  return obj;\n}\n\nfunction exec(url, route, opts) {\n  var reg = /(?:\\?([^#]*))?(#.*)?$/,\n      c = url.match(reg),\n      matches = {},\n      ret;\n\n  if (c && c[1]) {\n    var p = c[1].split('&');\n\n    for (var i = 0; i < p.length; i++) {\n      var r = p[i].split('=');\n      matches[decodeURIComponent(r[0])] = decodeURIComponent(r.slice(1).join('='));\n    }\n  }\n\n  url = segmentize(url.replace(reg, ''));\n  route = segmentize(route || '');\n  var max = Math.max(url.length, route.length);\n\n  for (var i$1 = 0; i$1 < max; i$1++) {\n    if (route[i$1] && route[i$1].charAt(0) === ':') {\n      var param = route[i$1].replace(/(^:|[+*?]+$)/g, ''),\n          flags = (route[i$1].match(/[+*?]+$/) || EMPTY$1)[0] || '',\n          plus = ~flags.indexOf('+'),\n          star = ~flags.indexOf('*'),\n          val = url[i$1] || '';\n\n      if (!val && !star && (flags.indexOf('?') < 0 || plus)) {\n        ret = false;\n        break;\n      }\n\n      matches[param] = decodeURIComponent(val);\n\n      if (plus || star) {\n        matches[param] = url.slice(i$1).map(decodeURIComponent).join('/');\n        break;\n      }\n    } else if (route[i$1] !== url[i$1]) {\n      ret = false;\n      break;\n    }\n  }\n\n  if (opts.default !== true && ret === false) {\n    return false;\n  }\n\n  return matches;\n}\n\nfunction pathRankSort(a, b) {\n  return a.rank < b.rank ? 1 : a.rank > b.rank ? -1 : a.index - b.index;\n} // filter out VNodes without attributes (which are unrankeable), and add `index`/`rank` properties to be used in sorting.\n\n\nfunction prepareVNodeForRanking(vnode, index) {\n  vnode.index = index;\n  vnode.rank = rankChild(vnode);\n  return vnode.props;\n}\n\nfunction segmentize(url) {\n  return url.replace(/(^\\/+|\\/+$)/g, '').split('/');\n}\n\nfunction rankSegment(segment) {\n  return segment.charAt(0) == ':' ? 1 + '*+?'.indexOf(segment.charAt(segment.length - 1)) || 4 : 5;\n}\n\nfunction rank(path) {\n  return segmentize(path).map(rankSegment).join('');\n}\n\nfunction rankChild(vnode) {\n  return vnode.props.default ? 0 : rank(vnode.props.path);\n}\n\nvar customHistory = null;\nvar ROUTERS = [];\nvar subscribers = [];\nexports.subscribers = subscribers;\nvar EMPTY = {};\n\nfunction setUrl(url, type) {\n  if (type === void 0) type = 'push';\n\n  if (customHistory && customHistory[type]) {\n    customHistory[type](url);\n  } else if (typeof history !== 'undefined' && history[type + 'State']) {\n    history[type + 'State'](null, null, url);\n  }\n}\n\nfunction getCurrentUrl() {\n  var url;\n\n  if (customHistory && customHistory.location) {\n    url = customHistory.location;\n  } else if (customHistory && customHistory.getCurrentLocation) {\n    url = customHistory.getCurrentLocation();\n  } else {\n    url = typeof location !== 'undefined' ? location : EMPTY;\n  }\n\n  return \"\" + (url.pathname || '') + (url.search || '');\n}\n\nfunction route(url, replace) {\n  if (replace === void 0) replace = false;\n\n  if (typeof url !== 'string' && url.url) {\n    replace = url.replace;\n    url = url.url;\n  } // only push URL into history if we can handle it\n\n\n  if (canRoute(url)) {\n    setUrl(url, replace ? 'replace' : 'push');\n  }\n\n  return routeTo(url);\n}\n/** Check if the given URL can be handled by any router instances. */\n\n\nfunction canRoute(url) {\n  for (var i = ROUTERS.length; i--;) {\n    if (ROUTERS[i].canRoute(url)) {\n      return true;\n    }\n  }\n\n  return false;\n}\n/** Tell all router instances to handle the given URL.  */\n\n\nfunction routeTo(url) {\n  var didRoute = false;\n\n  for (var i = 0; i < ROUTERS.length; i++) {\n    if (ROUTERS[i].routeTo(url) === true) {\n      didRoute = true;\n    }\n  }\n\n  for (var i$1 = subscribers.length; i$1--;) {\n    subscribers[i$1](url);\n  }\n\n  return didRoute;\n}\n\nfunction routeFromLink(node) {\n  // only valid elements\n  if (!node || !node.getAttribute) {\n    return;\n  }\n\n  var href = node.getAttribute('href'),\n      target = node.getAttribute('target'); // ignore links with targets and non-path URLs\n\n  if (!href || !href.match(/^\\//g) || target && !target.match(/^_?self$/i)) {\n    return;\n  } // attempt to route, if no match simply cede control to browser\n\n\n  return route(href);\n}\n\nfunction handleLinkClick(e) {\n  if (e.ctrlKey || e.metaKey || e.altKey || e.shiftKey || e.button !== 0) {\n    return;\n  }\n\n  routeFromLink(e.currentTarget || e.target || this);\n  return prevent(e);\n}\n\nfunction prevent(e) {\n  if (e) {\n    if (e.stopImmediatePropagation) {\n      e.stopImmediatePropagation();\n    }\n\n    if (e.stopPropagation) {\n      e.stopPropagation();\n    }\n\n    e.preventDefault();\n  }\n\n  return false;\n}\n\nfunction delegateLinkHandler(e) {\n  // ignore events the browser takes care of already:\n  if (e.ctrlKey || e.metaKey || e.altKey || e.shiftKey || e.button !== 0) {\n    return;\n  }\n\n  var t = e.target;\n\n  do {\n    if (String(t.nodeName).toUpperCase() === 'A' && t.getAttribute('href')) {\n      if (t.hasAttribute('native')) {\n        return;\n      } // if link is handled by the router, prevent browser defaults\n\n\n      if (routeFromLink(t)) {\n        return prevent(e);\n      }\n    }\n  } while (t = t.parentNode);\n}\n\nvar eventListenersInitialized = false;\n\nfunction initEventListeners() {\n  if (eventListenersInitialized) {\n    return;\n  }\n\n  if (typeof addEventListener === 'function') {\n    if (!customHistory) {\n      addEventListener('popstate', function () {\n        routeTo(getCurrentUrl());\n      });\n    }\n\n    addEventListener('click', delegateLinkHandler);\n  }\n\n  eventListenersInitialized = true;\n}\n\nvar Router = function (Component$$1) {\n  function Router(props) {\n    Component$$1.call(this, props);\n\n    if (props.history) {\n      customHistory = props.history;\n    }\n\n    this.state = {\n      url: props.url || getCurrentUrl()\n    };\n    initEventListeners();\n  }\n\n  if (Component$$1) Router.__proto__ = Component$$1;\n  Router.prototype = Object.create(Component$$1 && Component$$1.prototype);\n  Router.prototype.constructor = Router;\n\n  Router.prototype.shouldComponentUpdate = function shouldComponentUpdate(props) {\n    if (props.static !== true) {\n      return true;\n    }\n\n    return props.url !== this.props.url || props.onChange !== this.props.onChange;\n  };\n  /** Check if the given URL can be matched against any children */\n\n\n  Router.prototype.canRoute = function canRoute(url) {\n    var children = (0, _preact.toChildArray)(this.props.children);\n    return this.getMatchingChildren(children, url, false).length > 0;\n  };\n  /** Re-render children with a new URL to match against. */\n\n\n  Router.prototype.routeTo = function routeTo(url) {\n    this.setState({\n      url: url\n    });\n    var didRoute = this.canRoute(url); // trigger a manual re-route if we're not in the middle of an update:\n\n    if (!this.updating) {\n      this.forceUpdate();\n    }\n\n    return didRoute;\n  };\n\n  Router.prototype.componentWillMount = function componentWillMount() {\n    ROUTERS.push(this);\n    this.updating = true;\n  };\n\n  Router.prototype.componentDidMount = function componentDidMount() {\n    var this$1 = this;\n\n    if (customHistory) {\n      this.unlisten = customHistory.listen(function (location) {\n        this$1.routeTo(\"\" + (location.pathname || '') + (location.search || ''));\n      });\n    }\n\n    this.updating = false;\n  };\n\n  Router.prototype.componentWillUnmount = function componentWillUnmount() {\n    if (typeof this.unlisten === 'function') {\n      this.unlisten();\n    }\n\n    ROUTERS.splice(ROUTERS.indexOf(this), 1);\n  };\n\n  Router.prototype.componentWillUpdate = function componentWillUpdate() {\n    this.updating = true;\n  };\n\n  Router.prototype.componentDidUpdate = function componentDidUpdate() {\n    this.updating = false;\n  };\n\n  Router.prototype.getMatchingChildren = function getMatchingChildren(children, url, invoke) {\n    return children.filter(prepareVNodeForRanking).sort(pathRankSort).map(function (vnode) {\n      var matches = exec(url, vnode.props.path, vnode.props);\n\n      if (matches) {\n        if (invoke !== false) {\n          var newProps = {\n            url: url,\n            matches: matches\n          };\n          assign(newProps, matches);\n          delete newProps.ref;\n          delete newProps.key;\n          return (0, _preact.cloneElement)(vnode, newProps);\n        }\n\n        return vnode;\n      }\n    }).filter(Boolean);\n  };\n\n  Router.prototype.render = function render(ref, ref$1) {\n    var children = ref.children;\n    var onChange = ref.onChange;\n    var url = ref$1.url;\n    var active = this.getMatchingChildren((0, _preact.toChildArray)(children), url, true);\n    var current = active[0] || null;\n    var previous = this.previousUrl;\n\n    if (url !== previous) {\n      this.previousUrl = url;\n\n      if (typeof onChange === 'function') {\n        onChange({\n          router: this,\n          url: url,\n          previous: previous,\n          active: active,\n          current: current\n        });\n      }\n    }\n\n    return current;\n  };\n\n  return Router;\n}(_preact.Component);\n\nexports.Router = Router;\n\nvar Link = function (props) {\n  return (0, _preact.createElement)('a', assign({\n    onClick: handleLinkClick\n  }, props));\n};\n\nexports.Link = Link;\n\nvar Route = function (props) {\n  return (0, _preact.createElement)(props.component, props);\n};\n\nexports.Route = Route;\nRouter.subscribers = subscribers;\nRouter.getCurrentUrl = getCurrentUrl;\nRouter.route = route;\nRouter.Router = Router;\nRouter.Route = Route;\nRouter.Link = Link;\nRouter.exec = exec;\nvar _default = Router;\nexports.default = _default;"},"sourceMaps":null,"error":null,"hash":"c6a89595f754437b7a9f1a3034b76dad","cacheData":{"env":{}}}